#include "pattern/pattern_resolution.hpp"
#include "pattern/pattern_registry.hpp"
#include <iostream>
#include <algorithm>

namespace tbx {

// Helper Visitor to scan for variable usage
struct VariableScanner : public ASTVisitor {
    std::unordered_set<std::string>& deducedVars;
    const std::vector<std::string>& rawSyntax;
    const PatternRegistry& registry;
    bool foundNew = false;

    VariableScanner(std::unordered_set<std::string>& vars, const std::vector<std::string>& syntax, const PatternRegistry& reg)
        : deducedVars(vars), rawSyntax(syntax), registry(reg) {}

    // Base Case: Intrinsic usage
    void visit(IntrinsicCall& node) override {
        for (const auto& arg : node.args) {
            if (auto* id = dynamic_cast<Identifier*>(arg.get())) {
                // Check if this identifier matches a word in the syntax
                if (std::find(rawSyntax.begin(), rawSyntax.end(), id->name) != rawSyntax.end()) {
                    if (deducedVars.insert(id->name).second) {
                        foundNew = true;
                    }
                }
            }
            arg->accept(*this);
        }
    }

    // Propagation: Pattern Call usage
    void visit(PatternCall& node) override {
        for (const auto& [paramName, expr] : node.bindings) {
            // If we pass an identifier as an argument to a known pattern parameter,
            // that identifier MUST be a variable in *our* pattern.
            if (auto* id = dynamic_cast<Identifier*>(expr.get())) {
                 if (std::find(rawSyntax.begin(), rawSyntax.end(), id->name) != rawSyntax.end()) {
                    if (deducedVars.insert(id->name).second) {
                        foundNew = true;
                    }
                }
            }
            expr->accept(*this);
        }
    }

    void visit(SetStatement& node) override {
        // Fallback for SetStatement generated by legacy parser
        if (std::find(rawSyntax.begin(), rawSyntax.end(), node.variable) != rawSyntax.end()) {
             if (deducedVars.insert(node.variable).second) {
                foundNew = true;
            }
        }
        node.value->accept(*this);
    }

    // Recursive traversal
    void visit(Program& node) override { for(auto& s: node.statements) s->accept(*this); }
    void visit(BlockExpr& node) override { for(auto& s: node.statements) s->accept(*this); }
    void visit(ExpressionStmt& node) override { 
        node.expression->accept(*this); 
    }
    void visit(IfStatement& node) override { 
        node.condition->accept(*this); 
        for(auto& s: node.then_branch) s->accept(*this);
        for(auto& s: node.else_branch) s->accept(*this);
    }
    void visit(WhileStatement& node) override {
        node.condition->accept(*this);
        for(auto& s: node.body) s->accept(*this);
    }
    
    // Others
    void visit(IntegerLiteral&) override {}
    void visit(FloatLiteral&) override {}
    void visit(StringLiteral&) override {}
    void visit(Identifier&) override {}
    void visit(BooleanLiteral&) override {}
    void visit(UnaryExpr& node) override { node.operand->accept(*this); }
    void visit(BinaryExpr& node) override { node.left->accept(*this); node.right->accept(*this); }
    void visit(NaturalExpr& node) override {
        // Scan tokens for identifiers that match raw_syntax words
        // These are potential variables used in intrinsic calls
        for (const auto& token : node.tokens) {
            if (token.type == TokenType::IDENTIFIER) {
                // Check if this identifier matches a word in the syntax
                if (std::find(rawSyntax.begin(), rawSyntax.end(), token.lexeme) != rawSyntax.end()) {
                    if (deducedVars.insert(token.lexeme).second) {
                        foundNew = true;
                    }
                }
            }
        }
    } 
    void visit(LazyExpr& node) override { node.inner->accept(*this); }
    void visit(FunctionDecl& node) override { for(auto& s: node.body) s->accept(*this); }
    void visit(PatternDef& node) override { /* Nested patterns ignored */ }
    void visit(ImportStmt&) override {}
    void visit(UseStmt&) override {}
    void visit(ImportFunctionDecl&) override {}
};


PatternResolver::PatternResolver(PatternRegistry& registry) : registry_(registry) {}

bool PatternResolver::resolveAll() {
    bool changed = true;
    int maxIterations = 100; // Safety break

    while (changed && maxIterations-- > 0) {
        changed = false;

        // We iterate raw definitions managed by the registry
        auto& rawDefs = registry_.getRawDefinitions();
        
        for (auto* def : rawDefs) {
             if (resolvePattern(def)) {
                 changed = true;
             }
        }
    }
    
    return true; 
}

bool PatternResolver::resolvePattern(PatternDef* def) {
    // Skip if already resolved
    if (resolvedDefs_.count(def)) return false;

    std::unordered_set<std::string> knownVars;
    VariableScanner scanner(knownVars, def->raw_syntax, registry_);

    for (const auto& stmt : def->when_triggered) {
        stmt->accept(scanner);
    }

    if (scanner.foundNew) {
            // Update syntax elements
            def->syntax.clear();
            for (const auto& word : def->raw_syntax) {
            PatternElement elem;
            elem.value = word;
            
            if (knownVars.count(word)) {
                elem.is_param = true;
                elem.param_type = PatternParamType::Normal;
            } else {
                elem.is_param = false;
                if (word.front() == '[' && word.back() == ']') {
                    elem.is_optional = true;
                    elem.value = word.substr(1, word.size() - 2);
                } else {
                    elem.is_optional = false;
                }
            }
            def->syntax.push_back(elem);
        }
        
        resolvedDefs_.insert(def);
        registry_.updateResolvedPattern(def);
        return true;
    }
    
    return false;
}

} // namespace tbx
