# 3BX Standard Prelude
# Core language patterns defined in 3BX itself

# === Return ===
# Defined first so it can be used in other patterns

effect return val:
    execute:
        @intrinsic("return", val)

# === Variables ===

effect set var to val:
    execute:
        @intrinsic("store", var, val)

# === Output ===

effect [print|write] msg [|to the console]:
    execute:
        @intrinsic("print", msg)

# === Arithmetic ===

expression left + right:
    get:
        return @intrinsic("add", left, right)

expression left - right:
    get:
        return @intrinsic("sub", left, right)

expression left * right:
    priority: before $ + $
    get:
        return @intrinsic("mul", left, right)

expression left / right:
    priority: before $ + $
    get:
        return @intrinsic("div", left, right)

# === Comparison ===
# These operate AFTER addition (lower priority)

expression val1 [is equal to|=] val2:
    priority: after $ + $
    get:
        return @intrinsic("cmp_eq", val1, val2)

expression val1 [is less than|<] val2:
    priority: after $ + $
    get:
        return @intrinsic("cmp_lt", val1, val2)

expression val1 [is greater than|>] val2:
    priority: after $ + $
    get:
        return @intrinsic("cmp_gt", val1, val2)

expression val1 [is less than or equal to|<=] val2:
    priority: after $ + $
    get:
        return @intrinsic("cmp_lte", val1, val2)

expression val1 [is greater than or equal to|>=] val2:
    priority: after $ + $
    get:
        return @intrinsic("cmp_gte", val1, val2)

expression:
	patterns:
		val1 != val2
		val1 <> val2
		val1 isn't [equal to|] val2
		val1 is not equal to val2
    priority: after $ + $
    get:
        return @intrinsic("cmp_neq", val1, val2)

# === Compound Assignment ===

effect multiply var by val:
    execute:
        set var to var * val

effect add val to var:
    execute:
        set var to var + val

effect subtract val from var:
    execute:
        set var to var - val

effect divide var by val:
    execute:
        set var to var / val

# === Control Flow ===

condition if cond [|then]:
    execute:
        @intrinsic("branch", cond)

section while {condition}:
    execute:
        @intrinsic("loop_while", condition, the calling section)

expression true:
	get:
		return 1

expression false:
	get:
		return 0

# === Compile-time Assertions ===

effect [make sure|verify] that {expression:cond}:
    when parsed:
        @intrinsic("assert_compile_time", cond)
